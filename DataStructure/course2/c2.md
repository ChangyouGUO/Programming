### 岛问题，分布式系统设计 
使用结构：并查集  
操作： is_same_size(), uion()  
查找最顶上的父节点，不同则不在一起。相同则一个集合  

并查集的一点优化：
    在每次判断is same size, 调用findFather时, 将结构扁平化，大大降低时间复杂度。  

时间复杂度:
样本数量为N: 如果 isSameSet + Union的调用次数 >= O(N), 单次调用 time O(1)

### 例题
中国统计湖数量/感染问题  
单cpu,单内存：
1. 0,1化 ==>> 矩阵中连成1片的1有多少  
2. 连接  

并行算法：并行算法是现在IO比赛中缺失的，但是工业界中很关注.  
记录岛的数量，边界点记录。查看边界点，相同则uion, 岛数量减1.  

islands 时间复杂度(O(N*M))


### 2. KMP算法  
判断str2是st1的子串，返回匹配的起点位置。否则返回-1。  

暴力解： O(N*M)  

关键点：
最长前缀，最长后缀。前后缀不能取到整体。  
求str2的最长前后缀  

KMP中 while发生的次数(O(N))  
评估的时候，找到两个量， i1, i1-i2. 在循环的三种情况中，这两个值都会增加。

next数组  
每个对应位置记录: 此位置前的字符串的最大最小缀长度.  
数组开头一定是[-1, 0]  

时间复杂度  
计算方法与上面一样。O(N)