# 1. 哈希函数

## 实际应用

    MD5, SHA1 码

## 特性

1. 无限输入对应有限输出
2. 不同输入可能对应一个输出
3. 输入一样，输出也一定一样
4. 完全不同的输入，输出均匀。输入与输出完全无关。哈希函数的均匀性和离散型是一件事。

## 拓展 / 理论基础

    疏密树

## 举例

20 亿个数，每个数 32 位，2G 内存，硬盘无限大，寻找出现频率最高的 10 个数。
假设保存格式：key(int) value(int), 4 bytes + 4 byte, 一条记录 8bytes.
忽略链接的一些空间，极端情况下 20 亿*8 字节，大于 160G

求解 :
哈希函数，取余数，分桶装入，再比较各桶中的前 10 个
增删改查：
可以认为是 o(1),
常数时间比较大

## 具体实现

哈希表经典形式：
桶，里面放单向链表
Java 改进：
桶，里面放有序表（红黑树）

## 例题

RandomPool
应用于一致性哈希中，虚拟节点和数据服务器的匹配对应关系。

# 2. 位图，每一位用一个 bit 表示

```C++
    int bitmap[10];
    int i = 178;
    get   : ((bitmap[i / 32] >> (i % 32)) & 1)
    set 0 : bitmap[i/32] & (~(1<<(i%32)))
    set 1 : bitmap[i/32] | (1<<(i%32))
```

# 3. 布隆过滤器，大系统。

## 应用场景

    黑名单系统，爬虫去重场景；
优点  
    极大简化占用的内存  
缺点  
    一定存在失误率；
    例如黑名单系统，不会把黑名单误检为白名单，可能白名单误检为黑名单。
    不会漏检，只会误检。
    失误率可以压得很低。

## 布隆过滤器实现

使用比特位数组，假设长度为 m，哈希函数 k 个。与单样本的大小（字节）无关，与样本数量有关。

样本个数 n, 预期失误率 p.
理论值 m = -(n*lnP)/((ln2)^2)。向上取整
在一定宽松条件下拿到实际值，m'。

k = ln2 * (m/n) 大约为 0.7*(m/n). 向上取整
在一定宽松条件下拿到实际值 k'

真实失误率：
P 真 = （1-e(-(n*k')/m'))^(k')
此时 p 通常低于预期失误率。因为 m,k 都是宽松条件下的偏大值。

# 4. 一致性哈希，分布式系统，一定使用一致性哈希。

## 数据服务器的组织结构。

逻辑服务器 （每台机器等效，代码一样）
数据库 (DB)
当数据输入时，逻辑端求哈希函数，模一下，找到存储对应的数据端。

哈希 key 的种类要多，类似姓名。
种类多，每个数据端都有高频，低频，中频，负载会很均衡。

优点
    通常情况下负载均衡。
缺点
    如何处理，增减后端 DB 服务器机器。仅用通常的哈希函数，新加入机器后，代价是所有数据需要重新计算哈希值。

## 一致性哈希，既能负载均衡，又能增减机器。

把哈希函数的返回值想象成一个环，收尾相接。

### 具体流程

数据服务器 (m1, m2, m3)
机器有专属的的标识用于计算哈希值，将此值也放在环上，每个机器负责（顺时针）节点前的一段数据。
当增加机器时，迁移的数据是此机器对应点到上一个点的数量。

将数据机器的 m 值，进行排序，放在逻辑端机器上。
对于每个数据，计算哈希值，将数据放在比他大的服务器上。

### 问题

服务器（数量少）的哈希值，不均分环。服务器负载不均衡。
加减机器后，服务器负载不均衡。

### 通过虚拟节点技术解决

例如，3 个机器，每个分配 1000 个虚拟节点
可以找到机器 ->虚拟节点，虚拟节点 ->机器的对应关系。
此时 3000 个点均分环。

当加入新机器，就加入 1000 个节点。调整时，理论上新机器减轻每个机器一样的负载。

***比例的思维***

不仅可以做到负载均衡，也可以做到管理负载。机器能力强，占用的节点可以多。

# 4. 岛问题，分布式系统设计
