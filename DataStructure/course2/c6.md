# 有序表  
## 用法  
C++  sorted map  
Java  TreeMap 红黑树  
有序表，内部key是有序的, 所以相比哈希表多了一些操作  

哈希表: 散乱表，所有增删改查是O(1)  
有序表: 所有的增删改查是O(logN), 工程中较多使用，N不是很大。  


## 如何构成  
平衡搜索二叉树  
### 搜索二叉树  
左小右大，依次插入。性能依赖输入的状况.  
删除时，节点既有左孩子，又有右孩子, 使用右孩子的最左节点。

### 实现有序表  
红黑树，AVL树，size-balance tree, 跳表。  
实现相同接口，性能为O(N)  

前三个全是平衡搜索二叉树.  
最严格的是AVL树: 左树高度与右树高度差<=1.  
红黑树: 最长链长度与最短链长度相差最大不超过1倍以上. (阉割平衡性)  
SB树: 叔叔节点不能比侄子节点数量少，其实就是子树规模差不多. (阉割平衡性)  

### AVL树  
https://github.com/ignl/BinarySearchTrees  
左旋，右旋. O(1)  
父节点放在哪一边儿。
  
插入节点后，从被加节点开始向上，逐一调整，即使向上每个点进行调整，代价也是O(logN).  
删除节点。只要不是两个都有，删除后，调整父节点及向上。如果两个节点都有，调整替换节点及向上的每个节点。  

AVL树不平衡的种类有4种:  
LL左孩子的左链太长, LR, RL, RR.  
LL: 右旋  
RR: 左旋  
LR: 左子树的右孩子变为此树节点。先左旋，再右旋。  
RL: 先右旋再左旋。  

推荐使用size-balance tree  

### 跳表  
有多少层，由扔筛子决定。随机打乱输入规律。  
高层数据少，底层数据多。高层移动，跳过好多底层数据。  

**常考，有可能现场手撸.**  

### SB TREE  
插入节点时，调整平衡性。删除时不需要。常数项最好.  

叔节点个数与侄子数量的个数。  
四种类型与AVL树一样。  
1. 做对应情况的旋转。  
2. 对子节点有变化的节点，重新调整.  
















