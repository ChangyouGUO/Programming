### manachure

#### 解决最长回文子串（连续）的长度  

1. 用途  
DNA 碱基对配对，回文子串有一定意义。  

2. 暴力求解  
以每个点为中心，进行左右扩张，求回文子串。  
2.1 问题：  
长度为奇数的可以检查到，偶数回文不行。  
122131221  
2.2 解决方法：  
给字符串每个位置添加特殊字符。  
"#1#2#2#1#3#1#2#2#1#"  
长度/2  
特殊字符可以选任何值，虚轴和虚轴比较，实轴和实轴比对。  
2.3 复杂度：  
O(n^2)  

3. 铺垫  
3.1 回文直径，回文半径数组
半径数组包含中心点。

3.2 最右回文右边界  R
只要边界往右了，就记录下来  
初始值为-1

3.3 中心点 C
取得最右回文右边界对应的中心点

4. 分类过程
4.1  i在R外  
暴力求解，直接扩展
4.2  i在R内 
存在结构 
[ i'       c        i ]  
                      R
以i'的回文半径最作为判断条件  
4.2.1  
i'的R 在L,R中  
[a bcdcb kstsk bcdcb a]
     i     c     i   R  
此时不用计算，i此时的R为i' 的R  O(1)  

4.2.2  
i' R在L或R的外边  
ab [cdcba kstskabcdc]F  
   L i'     c     i R  
此时i的半径为 R-i 的距离  O(1)  

4.2.3  
i' R 和 L压线  
[abcdcba kskabcdcba]?
    i'    c    i   R  
节省了R-i的验证区域，能否向外延伸，需要继续验证  

5. 伪代码  
"""JAVA  
   // str是加入过#之后的串
   char[] str = null;
   int[] pArr = null;

   for(int i=0; i<str.length; i++){
       if(i在R外) {
           暴力扩之后，确定pArr[i]
       }else{ // i在R内
           if(情况一: i'的回文区域彻底在L, R内部){
               O(1)时间内确定 pArr[i] = pArr[i']
           } else if(情况二: i'的回文区域跑到L, R外) {
               O(1)时间内确定 pArr[i] = i到R的距离
           } else { 情况三: i'的回文区域左边界和L压线
                不用验证i-R, 只用从R外的位置开始验证;
                扩完后，确定pArr[i]
           }
       }
   }
"""

每个位置，会失败1次， 失败总数O(N)  
每个位置，会拓成功总数O(N). 成功总次数与R绑定，O(N)  


6. 代码优雅实现  
注意实现  


7. 窗口内最大值，最小值  
解决窗口滑动问题(注意使用范围)  
R往右动，右侧一个数进入  
L往左动，左侧一个数出去  
L永远不要突破R  

要求窗口内的最大值?  
例如: 35246729  
使用双端队列，要求队列从大到小排列  

记录index，若R往右动，从尾巴添加，要求数值排列从大到小，不满足则弹出尾巴后，再添加。若L向右动，查看左侧最大值是否过期，过期，则弹出头部。  

双端队列含义是: L往右动的过程中，窗口内可能成为最大值的列表  

均摊下来，平均调整次数为O(1)  

例题:
给定一个数组，已给阈值t, 求数组中子串符合 max-min <= t的个数?

暴力求解:  
所有子串O(n^2), 求大，求小O(n), 整体O(n^3)

最优解O(n):
特性: 若字符串中max-min <= t, 则此字符串中所有子串均符合。
     若字符串中max-min > t, 则包含这个子串的所有串均不符合。  

求解:  
两个双端队列，一个最大值，一个最小值。先向右侧扩到停止，此时R-L长度即为以L开头所有子串的个数。调整L右移直到再次满足条件，调整R到最大范围。  


8. 单调栈
解决: 在一个数组中找到某值距离最近其自身的最大值，最小值  

暴力解法: 
O(n^2)  

单调栈: 
O(n^2)  

求数组中每个值最近的最小值，单调栈要求从小到大。结果体现在每个被弹出的值，此值左侧最小值为底下压着的数，此值的右侧最小值为使得他弹出的值。

有连续重复值如何解决:  
写栈时，下标压在一起，弹出时一起弹出。  
清算时，弹出值左侧的最小值，取压在一起下标的最大值。
